---
title: 'Tipologia i cicle de vida de les dades'
subtitle: 'Pràctica 2: Neteja i anàlisi de les dades'
author: "Autors: Adrià Tarradas i Aleix Arnau Soler"
date: "Desembre 2020"
output:
  pdf_document:
    highlight: zenburn
    toc: yes
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
header-includes:
   - \usepackage[justification=raggedright,labelfont=bf,singlelinecheck=false]{caption}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
#Càrrega de llibreries

library("readr")
library("stringr")
library(kableExtra)
library(tibble)
library(dplyr)
library(ggplot2)
library(plyr)
library(ggpubr)
library('VIM')
```

\newpage

# 1. Presentació del projecte de ciència de dades

## 1.1. Background

L’enfonsament del Titanic és un dels naufragis més famosos de la història.
El 15 d'abril de 1912, durant el seu viatge inaugural, el considerat "inenfonsable" RMS Titanic es va enfonsar després de xocar amb un iceberg. Malauradament, no hi havia prou bots salvavides per a tothom a bord, cosa que va provocar la mort de 1502 de 2224 passatgers i tripulants. Tot i que hi va haver algun element de sort per sobreviure, sembla ser que alguns grups de persones tenien més probabilitats de sobreviure que d’altres.

## 1.2. Objectiu

L'objectiu d'aquesta pràctica és la creació final d'un o varis models predictius que responguin a la pregunta: **"quin tipus de persones tenien més probabilitats de sobreviure?"**. Per això, caldrà primer netejar i analitzar les dades dels passatgers a bord del RMS Titanic (*i.e.* nom, edat, sexe, classe socioeconòmica, etc.) abans de construir els models per a predir quins passatgers van sobreviure a l'enfonsament del Titanic.

## 1.3. Descripció del dataset

El dataset que utilitzarem en aquesta pràctica és *Titanic: Machine Learning from Disaster*, disponible clicant a [*aquí*](https://www.kaggle.com/c/titanic). 

Aquest conjunt de dades està compost per diversos atributs/característiques dels passatgers del titanic distribuïts en 2 fitxers: un dataset per entrenar els models i un altre per a testar-los. A més, s'incou un fitxer amb la predicció de la supervivencia dels passatgers (codificat com a 0: mort o 1: sobreviu) que assumeix que totes les dones, i només les dones, sobreviuen. Obviament, aquestes prediccions són irreals pero ens serveixen com a exemple de com hauria de ser el fitxer final amb les prediccions de supervivencia en cas de que es participés a una de les competició de [*Kaggle*](https://www.kaggle.com/). És per aquest motiu que les dades es proporcionen ja semparades en un dataset d'entrenament i un dataset de testeig, ja que així tots els membres que participen a la cometició de la web Kaggle parteixen de la mateixa informació i dades, i per tant es poden comparar entre ells els resultats obtinguts amb els diferents models implentats. 


Els fitxers que componen el dataset són:

* **train.csv**: Conté totes les dades i variables d'un subgrup dels passatgers a bord del RMS Titanic (891 passatgers i tripulants), a més de la variable que ens indica si aquell passatger va morir o sobreviure. Aquest dataset serà el que s'utilitzarà per l'entrenament d'un model.

* **test.csv**: Conté totes les dades i variables d'un subgrup més petit que l'anterior dels passatgers a bord del RMS Titanic (en aquest cas 418 passatgers i tripulants) amb l'excepció de que aquest dataset no conté la variable que ens indica si el passatger va sobreviure o no. Aquestes dades s'utilitzaran per a poder testejar els models creats amb les dades del dataset d'entrenament.

* **gender_submission.csv**: Conté la classe dels passatgers (si sobreviuen o no) vinculada a l'identificador de cada passatger, assumint que totes les dones, i només les dones, haguessin sobreviscut.

Cada passatger conté informació de les següents variables:

```{r  include=FALSE}
table<-matrix(c("PassangerID","Survived","Pclass","Name","Sex","Age","SibSp","Parch","Ticket","Fare","Cabin","Embarked","Número identificador del passatger","Enter que indica si el passatger va sobreviure l'enfonsament o no","Enter que indica el tipus de tiquet del passatger","Títol/Nom del passatger","Sexe del passatger","Edat del passatger (anys)","Número de cònjuges i germans del passatger a bord","Número de pares i fills del passatger a bord","Número del tiquet del passatger","Preu pagat/Tarifa del viatge","Número de cabina","Port en el que ha embarcat el passatger","","0 = No, 1 = Sí","1 = 1a classe, 2 = 2a classe, 3 = 3a classe","","","","","","","","","C = Cherbourg, Q = Queenstown, S = Southampton"),ncol=3)
colnames(table)<-c("Variables","Definició","Codificació")
rownames(table)<-c("","","","","","","","","","","","")
table_contributions<-as.table(table)
table_contributions
```

\newpage
```{r ,echo=FALSE}
knitr::kable(table_contributions, caption = "Data diccionary: resum de les variables del dataset 'Titanic: Machine Learning from Disaster'.")%>% 
  kable_styling(latex_options="scale_down")
```

Notes a tenir en compte:
* La variable **pclass** ens serveix com a indicador indirecte del nivell socioeconomic del passatger (alt: 1a classe, mitjà: 2a classe, baix: 3a classe).
* L'edat dels menors d'1 any està codificada com la fracció d'any que tenen. Les edats és mostren com a fraccions on en alguns casos s'indica' el 'i mig' (e.g. 35.50 = 35 anys i mig)
* Alguns nens viatjaven amb una mainadera, per tant és possible que per algun d'ells 'parch' sigui 0.

\newpage

# 2. Integració i comprobació

Un cop les dades s'han descarregat des de l'enllaç proporcionat, carreguem les dades a l'entorn de treball.

```{r}
train_raw <- read.csv("data/train.csv", sep=',', stringsAsFactors = FALSE)
test_raw <- read.csv("data/test.csv", sep=',', stringsAsFactors = FALSE)
test_class_raw <- read.csv("data/gender_submission.csv", sep=',', stringsAsFactors = FALSE)
```

Primer inspeccionem els datasets
```{r}
head(train_raw)
```
```{r}
head(test_raw)
```

```{r}
head(test_class_raw)
```

Primer de tot extreurem la variable 'Survived' del dataset d'entrenament en un format igual al dataset 'gender_submission.csv' ja que aquesta no ens farà falta de moment i així podem integrar els dos datasets en un de sol per a dur a terme la neteja, inspecció i analisis en un sol dataset.

```{r}
train_predictions<-train_raw[,c("PassengerId","Survived")]
train_raw<-train_raw[,-2]
```

Comprovem que les dades s'han carregat correctamen i les inspeccionem.
Dataset d'entrenament:

```{r}
# Comprovem que les dimensions del dataset siguin les esperades
dim(train_raw)
# Comprovem en quina classe es troben les variables
sapply(train_raw,class)
# Comprovem l'estructura
str(train_raw)
# Inspeccionem alguns parametres bàsics
summary(train_raw)
# Inspeccionem les dades
glimpse(train_raw)
```

Dataset de testeig:

```{r}
# Comprovem que les dimensions del dataset siguin les esperades
dim(test_raw)
# Comprovem en quina classe es troben les variables
sapply(test_raw,class)
# Comprovem l'estructura
str(test_raw)
# Inspeccionem alguns parametres bàsics
summary(test_raw)
# Inspeccionem les dades
glimpse(test_raw)
```

Les dimensions són les esperades i el format és equivalent entre els dos datasets.

```{r}
head(train_raw)
head(test_raw)
```
Integrem les dades dels dos datasets en un de sol.
```{r}
dataset<-rbind(train_raw,test_raw)
head(dataset)
dim(dataset)
```

A partir de la informació observada decidim canviar les classes d'algunes variables. Al canviar la classe de la variable 'Age', tots aquells passatgers menors d'1 any passaran a tenir edat = 0 (indicatiu de que tenen mesos de vida)

```{r}
dataset <- within(dataset, {
  Pclass <- factor(Pclass)
  Sex <- factor(Sex)
  Age <- as.integer(Age)
  Embarked <- factor(Embarked)
})
```

Tornem a inspeccionar:

```{r}
# Inspeccionem les dades
glimpse(dataset)
```

**Observacions:**

* Les dimensions són les esperades.
* De la variable 'Name' es poden extreure els títols d'algunes persones.
* La variable 'Sex' es podria codificar de forma binaria.
* La variable 'Fare' sembla representar el preu total pagat alhora de comprar més d'un tiquet junts (e.g. families) envés del tiquet individual.
* Podem crear 'dummy' variables per a les variables 'Pclass', 'Sex' i 'Embarked'
* De la variable 'cabin' es pot extreure la lletra que segurament representa diferentes zones del vaixell.
* Dels resultats de la funció summary() i glimpse() es pot veure com tenim varis valors nuls o mencants en les variables: Age, Fare, Cabin i Embarked

# 3. Neteja de dades

## 3.1. Gestió de valors buits o nul

Creem una funció que indica les variables que contenen valors nul i l'executem passant-li el dataset que hem carregat.

```{r}
has_na <- function(dades) {
  no_na <- TRUE
  for (i in names(dades)) {
    a <- sum(is.na(dades[[i]]))
    if (a != 0) {
      no_na <- FALSE
      print(paste("La variable ", i, " té ", a, " valors nul"))
    }
    else if (a == 0 & is.character(dades[[i]])) {
      b <- length(dades[[i]][which(dades[[i]]=="")])
      if (b != 0) {
        no_na <- FALSE
        print(paste("La variable ", i, " té ", b, " valors buits"))
      }
    }
  }
  if (no_na) {
    print("No hi ha cap variable amb valors nul")
  }
}
```

Un cop creada la funció l'executem per saber quines variables tenen valors nul en els diferents datasets.
Dataset d'entrenament:

```{r}
has_na(dataset)
```

```{r}
# Observant les dades veiem que la variable 'Embarked' també té 2 valors buits no identificats amb la funció que hem definit.
table(dataset$Embarked,useNA='always')

# Aquests es troben en el passatger número 62 i 830
dataset[which(dataset$Embarked==""),]
```
Com que només es tracta de dos valors, i aquest passatgers viatjaven sols, assumirem que aquests passatgers van embarcar al mateix port que la majoria de passatgers ('S'). De donar-se el cas de que algun d'aquests viatgers no viatges sol, també podriem assumir que que el port d'embarcament era el mateix que els seus familiars. Aquest el podriem trobar mitjançant el cognom o nom de familia del passatger.

```{r}
dataset[62,]$Embarked<-'S'
dataset[830,]$Embarked<-'S'

table(dataset$Embarked,useNA='always')
```

En quan a la variable 'Fare', assumirem que aquest té el mateix valor mig que el que altres passatgers de viatjant en circumstancies similars van pagar.
```{r}
# Aquests es troba en el passatger número 1044
dataset[which(is.na(dataset$Fare)),]

dataset[1044,]$Fare<-mean(dataset[which(dataset$Pclass==3&dataset$SibSp==0&dataset$Parch==0),]$Fare,na.rm = T)

dataset[1044,]$Fare

```

La variable 'Cabin' conté molts valors mencants, per a tant els tractarem com a mencants i no intentarem imputar els que falten.

En quan a la variable 'Age' imputarem les edats mencants segons el grup al que pertanyi cadascun dels passatgers on aquestes dades manquen. Hem decidit que fariem servir les variables 'Sex', 'Pclass' i 'Parch' igual o diferent a 0 per a crear els grups dels quals imputar les edats mancants.

```{r}

dataset.maleC1Parch0<-dataset[which(dataset$Sex=='male'&dataset$Pclass=='1'&dataset$Parch<1),]
dataset.maleC1Parch1<-dataset[which(dataset$Sex=='male'&dataset$Pclass=='1'&dataset$Parch>=1),]
dataset.maleC2Parch0<-dataset[which(dataset$Sex=='male'&dataset$Pclass=='2'&dataset$Parch<1),]
dataset.maleC2Parch1<-dataset[which(dataset$Sex=='male'&dataset$Pclass=='2'&dataset$Parch>=1),]
dataset.maleC3Parch0<-dataset[which(dataset$Sex=='male'&dataset$Pclass=='3'&dataset$Parch<1),]
dataset.maleC3Parch1<-dataset[which(dataset$Sex=='male'&dataset$Pclass=='3'&dataset$Parch>=1),]
dataset.femaleC1Parch0<-dataset[which(dataset$Sex=='female'&dataset$Pclass=='1'&dataset$Parch<1),]
dataset.femaleC1Parch1<-dataset[which(dataset$Sex=='female'&dataset$Pclass=='1'&dataset$Parch>=1),]
dataset.femaleC2Parch0<-dataset[which(dataset$Sex=='female'&dataset$Pclass=='2'&dataset$Parch<1),]
dataset.femaleC2Parch1<-dataset[which(dataset$Sex=='female'&dataset$Pclass=='2'&dataset$Parch>=1),]
dataset.femaleC3Parch0<-dataset[which(dataset$Sex=='female'&dataset$Pclass=='3'&dataset$Parch<1),]
dataset.femaleC3Parch1<-dataset[which(dataset$Sex=='female'&dataset$Pclass=='3'&dataset$Parch>=1),]

# Comprovem que les particions estan bé
nrow(dataset.maleC1Parch0)+
nrow(dataset.maleC1Parch1)+
nrow(dataset.maleC2Parch0)+
nrow(dataset.maleC2Parch1)+
nrow(dataset.maleC3Parch0)+
nrow(dataset.maleC3Parch1)+
nrow(dataset.femaleC1Parch0)+
nrow(dataset.femaleC1Parch1)+
nrow(dataset.femaleC2Parch0)+
nrow(dataset.femaleC2Parch1)+
nrow(dataset.femaleC3Parch0)+
nrow(dataset.femaleC3Parch1)

```

Comprovem si cadascun dels grups mostre distribucions d'edat amb mitjanes diferents.

```{r}

#maleC1Parch0
age_mean1 <- mean(dataset.maleC1Parch0$Age, na.rm = T)
age_median1 <- median(dataset.maleC1Parch0$Age, na.rm = T)

p_maleC1Parch0<-ggplot(dataset.maleC1Parch0, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean1, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median1, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="maleC1Parch0")

#maleC1Parch1
age_mean2 <- mean(dataset.maleC1Parch1$Age, na.rm = T)
age_median2 <- median(dataset.maleC1Parch1$Age, na.rm = T)

p_maleC1Parch1<-ggplot(dataset.maleC1Parch1, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean2, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median2, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="maleC1Parch1")

#maleC2Parch0
age_mean3 <- mean(dataset.maleC2Parch0$Age, na.rm = T)
age_median3 <- median(dataset.maleC2Parch0$Age, na.rm = T)

p_maleC2Parch0<-ggplot(dataset.maleC2Parch0, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean3, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median3, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="maleC2Parch0")

#maleC2Parch1
age_mean4 <- mean(dataset.maleC2Parch1$Age, na.rm = T)
age_median4 <- median(dataset.maleC2Parch1$Age, na.rm = T)

p_maleC2Parch1<-ggplot(dataset.maleC2Parch1, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean4, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median4, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="maleC2Parch1")

#maleC3Parch0
age_mean5 <- mean(dataset.maleC3Parch0$Age, na.rm = T)
age_median5 <- median(dataset.maleC3Parch0$Age, na.rm = T)

p_maleC3Parch0<-ggplot(dataset.maleC3Parch0, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean5, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median5, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="maleC3Parch0")

#maleC3Parch1
age_mean6 <- mean(dataset.maleC3Parch1$Age, na.rm = T)
age_median6 <- median(dataset.maleC3Parch1$Age, na.rm = T)

p_maleC3Parch1<-ggplot(dataset.maleC3Parch1, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean6, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median6, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="maleC3Parch1")

#femaleC1Parch0
age_mean7 <- mean(dataset.femaleC1Parch0$Age, na.rm = T)
age_median7 <- median(dataset.femaleC1Parch0$Age, na.rm = T)

p_femaleC1Parch0<-ggplot(dataset.femaleC1Parch0, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean7, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median7, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="femaleC1Parch0")

#femaleC1Parch1
age_mean8 <- mean(dataset.femaleC1Parch1$Age, na.rm = T)
age_median8 <- median(dataset.femaleC1Parch1$Age, na.rm = T)

p_femaleC1Parch1<-ggplot(dataset.femaleC1Parch1, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean8, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median8, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="femaleC1Parch1")

#femaleC2Parch0
age_mean9 <- mean(dataset.femaleC2Parch0$Age, na.rm = T)
age_median9 <- median(dataset.femaleC2Parch0$Age, na.rm = T)

p_femaleC2Parch0<-ggplot(dataset.femaleC2Parch0, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean9, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median9, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="femaleC2Parch0")

#femaleC2Parch1
age_mean10 <- mean(dataset.femaleC2Parch1$Age, na.rm = T)
age_median10 <- median(dataset.femaleC2Parch1$Age, na.rm = T)

p_femaleC2Parch1<-ggplot(dataset.femaleC2Parch1, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean10, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median10, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="femaleC2Parch1")

#femaleC3Parch0
age_mean11 <- mean(dataset.femaleC3Parch0$Age, na.rm = T)
age_median11 <- median(dataset.femaleC3Parch0$Age, na.rm = T)

p_femaleC3Parch0<-ggplot(dataset.femaleC3Parch0, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean11, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median11, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="femaleC3Parch0")

#femaleC3Parch1
age_mean12 <- mean(dataset.femaleC3Parch1$Age, na.rm = T)
age_median12 <- median(dataset.femaleC3Parch1$Age, na.rm = T)

p_femaleC3Parch1<-ggplot(dataset.femaleC3Parch1, aes(Age)) +
  geom_density(fill = 'orchid', alpha =0.7) +
  geom_vline(aes(xintercept = age_mean12, color = 'mean'), linetype = 5) +
  geom_vline(aes(xintercept = age_median12, color = 'median'), linetype = 5) +
  scale_color_manual(name = "stats", values = c(mean = 'indianred', median = 'steelblue')) +
  ggtitle(label ="femaleC3Parch1")


figure_Ages <- ggarrange(p_maleC1Parch0,p_maleC1Parch1,p_maleC2Parch0,p_maleC2Parch1,p_maleC3Parch0,p_maleC3Parch1,p_femaleC1Parch0,p_femaleC1Parch1,p_femaleC2Parch0,p_femaleC2Parch1,p_femaleC3Parch0,p_femaleC3Parch1, ncol = 3, nrow = 4)

figure_Ages
```


```{r}

impute_age <- function (x) {
    x[is.na(x)] <- median(x, na.rm = T)
    return(x)
}

impute_age(dataset.maleC1Parch0$Age)

dataset.maleC1Parch0$Age<-impute_age(dataset.maleC1Parch0$Age)
dataset.maleC1Parch1$Age<-impute_age(dataset.maleC1Parch1$Age)
dataset.maleC2Parch0$Age<-impute_age(dataset.maleC2Parch0$Age)
dataset.maleC2Parch1$Age<-impute_age(dataset.maleC2Parch1$Age)
dataset.maleC3Parch0$Age<-impute_age(dataset.maleC3Parch0$Age)
dataset.maleC3Parch1$Age<-impute_age(dataset.maleC3Parch1$Age)
dataset.femaleC1Parch0$Age<-impute_age(dataset.femaleC1Parch0$Age)
dataset.femaleC1Parch1$Age<-impute_age(dataset.femaleC1Parch1$Age)
dataset.femaleC2Parch0$Age<-impute_age(dataset.femaleC2Parch0$Age)
dataset.femaleC2Parch1$Age<-impute_age(dataset.femaleC2Parch1$Age)
dataset.femaleC3Parch0$Age<-impute_age(dataset.femaleC3Parch0$Age)
dataset.femaleC3Parch1$Age<-impute_age(dataset.femaleC3Parch1$Age)

dataset_imputed<-rbind(dataset.maleC1Parch0,dataset.maleC1Parch1,dataset.maleC2Parch0,dataset.maleC2Parch1,dataset.maleC3Parch0,dataset.maleC3Parch1,dataset.femaleC1Parch0,dataset.femaleC1Parch1,dataset.femaleC2Parch0,dataset.femaleC2Parch1,dataset.femaleC3Parch0,dataset.femaleC3Parch1)

dataset_imputed<-dataset_imputed[,c('PassengerId','Age')]
names(dataset_imputed[2])<-'Age_imp'

dataset<-merge(dataset,dataset_imputed,by = 'PassengerId')
```

## 3.2. Creació de variables

### 3.2.1. Creació variable 'Title'

A partir del nom dels passatgers es poden extreure els titols d'algun d'ells. 
```{r}

# Extreiem el 'titol' de cada passatger. Com que el format dels nomes sempre es el mateix podem seguir una estructura per trobar-los
dataset$title <- str_sub(dataset$Name, str_locate(dataset$Name, ",")[ , 1] + 2, str_locate(dataset$Name, "\\.")[ , 1] - 1)

# combines els títols dels passatgers en grups segons si considerem que formen part de la noblesa (i.e. tenen algun títol, o no)
# Titols nobles per homes
names_noblesa <- c("Capt", "Col", "Don", "Dr", "Jonkheer", "Major", "Rev", "Sir","Lady", "Mlle", "Mme", "Ms", "the Countess", "Dona")
dataset$title[dataset$title %in% names_noblesa] <- "noble"
dataset$title<-factor(dataset$title)
# Comprobem el resultat final
table(dataset$title)

```

### 3.2.2. Creació variable 'Zona'

De la variable 'cabin' extreiem la lletra que segurament representa la zona del vaixell on es troba la cabina.

```{r}
Zona <- dataset %>%
  select(Cabin) %>%
  mutate(Zona = factor(str_extract(Cabin, pattern = "^.")))

dataset$Zona<-Zona$Zona
```

### 3.2.3. Creació variable 'Familiy_Size'

El tamany de les families es pot inferir a partir de les variables 'SibSp' i 'Parch'. A més, tota aquella gent que comparteixi cognom és probable que formin part de la mateixa familia.

Dataset d'entrenament:

```{r}
#Creem la variable 'Familiy_name"
dataset$Family_name <- str_replace(string = dataset$Name, pattern = ",.*", replacement = "")

#Visualitzem les dades
dataset %>%
  select(Name, Family_name) %>%
  head(10)

#Ceem la variable 'Family_size' (sumem 1 per assegurar-nos de que el passatger també es té en compte en la seva propia familia)
dataset <- dataset %>%
  mutate(Family_size = SibSp + Parch + 1)

#Visualitzem les dades
dataset %>%
  select(Family_name, SibSp, Parch, Family_size) %>%
   arrange(Family_name)%>%
  head(10)

```

Categorizem el tamany de les families segons si el passatger va sol, en familia/grup gran o petit:

```{r}

dataset <- dataset %>%
  mutate(FamilyCat = factor(case_when(Family_size == 1 ~ 'sol'
                            ,Family_size > 1 & Family_size < 5 ~ 'petita'
                            ,Family_size >= 5 ~ 'gran')))


```

### 3.2.4. Creació variable 'Price_Person'

```{r}

dataset$Price_Per_Person<-dataset$Fare/dataset$Family_size


```
 
Podem visualitzar com ara el preu pagat per ticket per a cada passatger, es mou dins d'un rang logic segons la classe en la que viatjaven: 1a classe = >20 dolars, 2a class = 10-20 dollars, 3a classe = < 10 dolars.

```{r}
# Use semi-transparent fill
p_fare<-ggplot(dataset[which(dataset$Fare<100),], aes(x=Fare, fill=Pclass)) +
  geom_density(alpha=0.4)
p_fare
```

```{r}
# Use semi-transparent fill
p_priceperson<-ggplot(dataset[which(dataset$Price_Per_Person<100),], aes(x=Price_Per_Person, fill=Pclass)) +
  geom_density(alpha=0.4)
p_priceperson

```

Finalment, podem tornar a comprobar que només tenim valors mencants a la variable 'Cabin'

```{r}
has_na(dataset)
table(dataset$Embarked,useNA='always')
```

### 3.2.5. Creació variable 'AgeCat'

Categorizem l'edat dels passatgers en intervals de 5 anys amb l'objectiu de poder utilitzar aquesta variable a l'hora d'aplicar mètodes que utilitzen atributs categòrics en l'etapa d'anàlisi.

Observem quin és el rang de valors que pren la variable *Age.y* transformada prèviament:

```{r}
str(dataset$Age.y)
```

```{r}
dataset["AgeCat"] <- cut(dataset$Age.y, breaks = c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85), labels = c("0-5","5-10","10-15","15-20","20-25","25-30","30-35","35-40","40-45","45-50","50-55","55-60","60-65","65-70","70-75","75-80","80-85"))
```


## 3.3. Exploració i transformació de variables

```{r}




```


```{r}




```





## 3.4. Gestió de valors extrems (outliers)

També cal observar els valors extrems de les variables numèriques i considerar si es corresponen a valors errònis que cal evitar o bé són casos extrems que convé mantenir. Com hem vist enteriorment, tenim 4 variables a considerar: Age, SibSp, Parch i Fare.

Per començar l'anàlisi de valors atípics hem creat una funció que mostra els diagrames de caixa de les diferents variables numèriques:

```{r}
mostrar_diag_caixa <- function(dades, variables_numeriques) {
  mida <- ceiling(sqrt(length(variables_numeriques)))
  par(mfrow=c(2,2))
  for (i in variables_numeriques) {
    boxplot(dades[[i]], main=i, horizontal = TRUE)
  }
}
```

I una altra que indica textualment els valors atípics d'una variable:

```{r}
deteccio_valors_atipics <- function(dades,variables_numeriques) {
  for (i in variables_numeriques) {
    valors_atipics <- boxplot.stats(dades[[i]])$out
    if (length(valors_atipics != 0)) {
      print(paste("La variable", i, "té els valors atípics: "))
      print(valors_atipics)
    }
  }
}
```

Un cop creades les funcions, les cridem passant-los hi les dades de cada fitxer i un vector amb el nom de les variables numèriques que contenen:

```{r}
mostrar_diag_caixa(train_raw,c("Age","SibSp","Parch","Fare"))
```

```{r}
deteccio_valors_atipics(train_raw,c("Age","SibSp","Fare"))
```

### 3.4. Datasets final

```{r}
# El dataset final
dataset_final<-merge(dataset,train_predictions,by = "PassengerId", all = T)

# El dataset final d'entrenament
dataset_train<-dataset_final[which(!(is.na(dataset_final$Survived))),]
dim(dataset_train)

# El dataset final de test
dataset_test<-dataset_final[which(is.na(dataset_final$Survived)),]
dim(dataset_test)
```

\newpage

# 4. Anàlisis de les dades

## 4.1. Arbre de decisió

***

**Construcció del model**

***

Una manera d'analitzar el dataset és aplicant un model de classificació basat en arbre, el qual ens permetrà veure quines variables tenen més influència a l'hora de determinar la probabilitat de supervivència de cada passatger a partir de les variables que el configuren. 

Les variables que s'han utilitzat per construir el model són les següents:

* Pclass

* Sex

* Embarked

* title

* FamilyCat

* AgeCat

Per poder aplicar aquest mètode, és necessari entrenar el model a generar amb els registres corresponents al dataset de train i separar les variables descriptives de la classe que es vol predir. El següent tall de codi prepara les variables que s'utilitzaran a l'etapa d'entrenament i les que s'utilitzaran per avaluar la precisió del model. Com que de les variables de test no coneixem la classe definitiva el que farem serà partir el dataset d'entrenament en dos subconjunts un dels quals servirà per entrenar el model i l'altre per avaluar-lo (2/3 dels registres per l'avaluació i el 1/3 restant per a l'entrenament).

Com que les dades estan ordenades i cal barrejar-les per tal que la tria sigui el màxim d'equitativa possible i no interfereixi amb el resultat que proporcionarà el model. Per fer-ho, apliquem el següent codi i guardem el resultat a la variable *dataset_train_random*:

```{r}
set.seed(1912)
dataset_train_random <- dataset_train[sample(nrow(dataset_train)),]
str(dataset_train_random)
```

Per poder aplicar la funció relativa a la construcció del model cal diferenciar entre les variables descriptives i la classe. Això ho fem seleccionant l'índex de la columna on es troba la classe (columna 7) i la resta (columnes de la 1 a 6). Els valors corresponents a la classe els guardem a la variable y_car i els corresponents a les variables descriptives a la x_car:

```{r}
set.seed(1912)
y <- dataset_train_random[,20]
x <- dataset_train_random[,c(2,4,11,13,17,19)]
```

Un cop obtinguda la mostra desordenada, anem a dividir el conjunt d edades en mostres d'entrenament i test. El conjunt d'entrenament serà aquell que s'utilitzarà per construir el model i el conjunt de proves el que s'utilitzarà per avaluar la seva precisió. Seguidament obtenim els diferents conjunts d'entrenament i test a partir de la proporció de casos que hem triat per cada conjunt (2/3 i 1/3) utilitzant la funció *sample*:

```{r}
set.seed(1912)
indexes = sample(1:nrow(x), size=floor((2/3)*nrow(x)))
train_x <- x[indexes,]
train_y <- y[indexes]
test_x  <- x[-indexes,]
test_y  <- y[-indexes]
```

Per aplicar l'algoritme de construcció del model d'arbre de decisió cal que no existeixi cap variable que tingui valors corresponents a una cadena de caràcters buida. Per solucionar-ho canviem el valor d'aquesta categòria per la paraula "desconegut":

```{r}
levels(train_x$Embarked)[1] <- "desconegut"
levels(test_x$Embarked)[1] <- "desconegut"
```

Per poder executar el mètode cal que no existeixin valors nul, els eliminem. Per això hem creat una funció que retorna els indexs de les files que contenen algun valor nul en un dataframe.

```{r}
indices_with_na <- function(data) {
  iwn <- c()
  for (i in c(1:nrow(data))) {
    if (any(is.na(data[i,]))) {
      iwn <- c(iwn, i)
    }
  }
  return(iwn)
}
```

Comprovem utilitzant la funció has_na quants quines variables del dataset tenen valors nul:

```{r}
has_na(train_x)
has_na(test_x)
```

Veiem que només la variable AgeCat té valors nul, els suprimim utilitzant la funció *indices_with_na* i guardem el resultat en 4 variables noves:

```{r}
# Obtenim els indexs amb valors nul
iwn_train <- indices_with_na(train_x)
iwn_test <- indices_with_na(test_x)

# Eliminem les files de les variables descriptives
train_x_no_na <- train_x[-iwn_train,]
test_x_no_na <- test_x[-iwn_test,]

# Eliminem els valors de les variables corresponents a la classe
train_y_no_na <- as.factor(train_y[-iwn_train])
test_y_no_na <- as.factor(test_y[-iwn_test])
```

Comprovem que s'han suprimit correctament:

```{r}
has_na(train_x_no_na)
has_na(train_x_no_na)
```

I que tant les variables descriptives com les corresponents a la classe tenen la mateixa mida:

```{r}
nrow(train_x_no_na) == length(train_y_no_na)
nrow(test_x_no_na) == length(test_y_no_na)
```

Un cop preparades les variables que s'utilitzaran, creem el model utilitzant l'algoritme C5.0 de la llibreria C50 i observem un resum del model generat. 

```{r}
model_tree <- C50::C5.0(train_x_no_na, train_y_no_na, rules=TRUE)
summary(model_tree)
```

Podem observar gràficament el model generat si el construïm sense mostrar les regles i el passem a la funció plot:

```{r}
model_tree_for_plot <- C50::C5.0(train_x_no_na, train_y_no_na)
plot(model_tree_for_plot)
```

***

**Avaluació del model**

***

Amb el model d'arbre de decisió creat a partir de les dades del conjunt d'entrenament podem avaluar la seva eficiència intentant predir les dades que es troben al conjunt de prova. Per fer-ho utilitzem la funció *predict* de R que classifica els diferents registres del conjunt de prova (test_X) utilitzant el model que rep (model_tree).

```{r}
predicted_test <- predict(model_tree,test_x_no_na, type="class")
```

Si observem el resultat d'aquesta funció veiem que es correspon a un vector amb les etiquetes de la classe. Per comprovar la precisió de l'arbre avaluem quantes d'aquestes etiquetes predites es corresponen al valor real que té el registre comparant-lo amb el contingut de la variable *test_y_no_na*:

```{r}
precisio_model <- sum(predicted_test == test_y_no_na)/length(predicted_test)
print(paste("La precisió del model és de ", round(precisio_model*100,2), "%", sep=""))
```

# 5. Resultats finals

```{r}
```


```{r}
```

```{r}
```

# 6. Conclusions

```{r}
```


# 7. Bibliografia

- Gibergans, J. (2019). Regressió lineal simple. Editorial UOC.

- Gibergans, J. (2019). Regressió lineal múltiple. Editorial UOC.

- Guillén, M., Alonso, M. T. (2019). Models de regressió logística. Editorial UOC.

- Liviano, D., Pujol, M. (2019). Models de regressió i anàlisi multivariant amb R-Commander. Editorial UOC.






Integrem les dades del dataset de test amb les dades de les seves corresponents prediccions de supervivencia si les dones, i només les dones, haguessin sobreviscut.

```{r}
names(test_class_raw)[2]<-"AllWomenSurvived"
test_dataset<-merge(test_raw,test_class_raw,by = 'PassengerId')
head(test_dataset)
```



.............................
Compare the passenger Class with their position on the Deck
table(cabin_deck$Deck, cabin_deck$Pclass)

#Calculate the correlation of the 2 variables
cabin_deck %>% select(Pclass, Deck) %>%
  map_df(as.numeric) %>%
  cor(., use = 'complete.obs',method = 'pearson')

..............................

..............................
#plot the data  
ggplot(missing_fare_subset, aes(x = Fare)) +
  geom_density(fill = 'forestgreen') +
  scale_x_continuous(label = dollar_format(), breaks = seq(0, 60, by = 10)) +
  ggtitle("Density Distribution of Fares for 3rd Class Male Passengers Embarking from Southampton", subtitle = "n = 365")
..............................  
  
  
  




Mètodes de predicció
Arbres de decisió
Mètodes d'agregació

